import{r as s}from"./index.LFf77hJu.js";var P={exports:{}},L={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var W=s,x=Symbol.for("react.element"),M=Symbol.for("react.fragment"),$=Object.prototype.hasOwnProperty,A=W.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,F={key:!0,ref:!0,__self:!0,__source:!0};function T(e,r,t){var n,u={},i=null,a=null;t!==void 0&&(i=""+t),r.key!==void 0&&(i=""+r.key),r.ref!==void 0&&(a=r.ref);for(n in r)$.call(r,n)&&!F.hasOwnProperty(n)&&(u[n]=r[n]);if(e&&e.defaultProps)for(n in r=e.defaultProps,r)u[n]===void 0&&(u[n]=r[n]);return{$$typeof:x,type:e,key:i,ref:a,props:u,_owner:A.current}}L.Fragment=M;L.jsx=T;L.jsxs=T;P.exports=L;var J=P.exports,j=Object.prototype.hasOwnProperty;function _(e,r){var t,n;if(e===r)return!0;if(e&&r&&(t=e.constructor)===r.constructor){if(t===Date)return e.getTime()===r.getTime();if(t===RegExp)return e.toString()===r.toString();if(t===Array){if((n=e.length)===r.length)for(;n--&&_(e[n],r[n]););return n===-1}if(!t||typeof e=="object"){n=0;for(t in e)if(j.call(e,t)&&++n&&!j.call(r,t)||!(t in r)||!_(e[t],r[t]))return!1;return Object.keys(r).length===n}}return e!==e&&r!==r}const B=e=>e.length===0?"":`importScripts(${e.map(t=>`'${t}'`).toString()})`,G=(e,r,t)=>{const n=`
    ${B(r)};
    onmessage=(${q})({
      fn: ${e},
      transferable: '${t}'
    })
  `,u=new Blob([n],{type:"text/javascript"});return URL.createObjectURL(u)},q=e=>async r=>{const[t]=r.data;try{const n=await Promise.resolve(e.fn(...t)),u=a=>"ArrayBuffer"in self&&a instanceof ArrayBuffer||"MessagePort"in self&&a instanceof MessagePort||"ImageBitmap"in self&&a instanceof ImageBitmap||"OffscreenCanvas"in self&&a instanceof OffscreenCanvas,i=e.transferable==="auto"&&u(n)?[n]:[];postMessage(["idle",n],i)}catch(n){postMessage(["error",n])}},S=(e,r)=>{const t=s.useRef(r);return _(t.current,r)||(t.current=r),s.useCallback(e,t.current)};var c=(e=>(e.IDLE="idle",e.RUNNING="running",e.ERROR="error",e.EXPIRED="expired",e.KILLED="killed",e))(c||{}),O=(e=>(e.AUTO="auto",e.NONE="none",e))(O||{});const D={timeout:void 0,remoteDependencies:[],autoTerminate:!0,transferable:O.AUTO},C={resolve:()=>null,reject:()=>null},K=(e,r=D)=>{const{autoTerminate:t,transferable:n,remoteDependencies:u,timeout:i}={...D,...r},[a,l]=s.useState(c.IDLE),o=s.useRef(),g=s.useRef(C),p=s.useRef(),d=s.useCallback(()=>{var f;(f=o.current)!=null&&f._url&&(o.current.terminate(),URL.revokeObjectURL(o.current._url),g.current=C,o.current=void 0,clearTimeout(p.current))},[]),R=s.useCallback(f=>{t&&d(),l(f)},[t,d,l]),b=S(()=>{const f=G(e,u,n),m=new Worker(f);return m._url=f,m.onmessage=E=>{const[v,I]=E.data;switch(v){case c.IDLE:g.current.resolve(I),R(c.IDLE);break;default:g.current.reject(I),R(c.ERROR);break}},m.onerror=E=>{g.current.reject(E),R(c.ERROR)},i&&(p.current=setTimeout(()=>{d(),l(c.EXPIRED)},i)),m},[e,r,d]),y=s.useCallback((...f)=>new Promise((m,E)=>{var v;g.current={resolve:m,reject:E};const I=n===O.AUTO?f.filter(h=>"ArrayBuffer"in window&&h instanceof ArrayBuffer||"MessagePort"in window&&h instanceof MessagePort||"ImageBitmap"in window&&h instanceof ImageBitmap||"OffscreenCanvas"in window&&h instanceof OffscreenCanvas):[];(v=o.current)==null||v.postMessage([[...f]],I),l(c.RUNNING)}),[n]),U=s.useCallback((...f)=>{try{if(a===c.RUNNING)throw new Error("[useWorkerFunc] You can only run one instance of the worker at a time, if you want to run more than one in parallel, create another instance with the hook useWorkerFunc(). Read more: https://github.com/jpwallace22/use-react-workers");return(t||!o.current)&&(o.current=b()),y(...f)}catch(m){return console.error(m),Promise.reject(`Web worker "${e.name}" is already running`)}},[a,t,y,b,e]),k=s.useCallback(()=>{d(),l(c.KILLED)},[d,l]),w={status:a,terminate:k};return s.useEffect(()=>{d()},[d]),[U,w]},z=(e,r)=>{const[t,n]=s.useState(r),[u,i]=K(e),a=async(...l)=>{const o=await u(...l);n(o)};return s.useEffect(()=>()=>i.terminate(),[]),[t,a,i]},X=(e,r)=>{const t=`
    ${B(r)};
    onmessage=(${H})({
      fn: ${e},
    })
  `,n=new Blob([t],{type:"text/javascript"});return URL.createObjectURL(n)},H=({fn:e})=>async r=>{const[t]=r.data;e(...t)},N={timeout:void 0,remoteDependencies:[],autoTerminate:!1,transferable:O.AUTO},Q=(e,r=N)=>{const{autoTerminate:t,transferable:n,remoteDependencies:u,timeout:i}={...N,...r},[a,l]=s.useState(c.IDLE),o=s.useRef(),g=s.useRef(),p=s.useCallback(()=>{var k;(k=o.current)!=null&&k._url&&(o.current.terminate(),URL.revokeObjectURL(o.current._url),o.current=void 0,clearTimeout(g.current))},[]),d=S(()=>{const k=X(e,u),w=new Worker(k);return w._url=k,i&&(g.current=setTimeout(()=>{p(),l(c.EXPIRED)},i)),w},[e,r,p]),R=s.useCallback((...k)=>{var w;(!o.current||a!==c.RUNNING)&&(o.current=d(),l(c.RUNNING));const f=n===O.AUTO?k.filter(m=>"ArrayBuffer"in window&&m instanceof ArrayBuffer||"MessagePort"in window&&m instanceof MessagePort||"ImageBitmap"in window&&m instanceof ImageBitmap||"OffscreenCanvas"in window&&m instanceof OffscreenCanvas):[];(w=o.current)==null||w.postMessage([[...k]],f)},[d,n,a]),b=s.useCallback(k=>{if(o.current)try{o.current.onmessage=w=>{k(w),t&&(p(),l(c.IDLE))}}catch(w){throw new Error(w)}finally{t&&(p(),l(c.IDLE))}},[t,p]),y=s.useCallback(()=>{p(),l(c.KILLED)},[p,l]),U=s.useMemo(()=>({postMessage:R,onMessage:b,terminate:y,status:a}),[R,b,y,a]);return s.useEffect(()=>{p()},[p]),U},V={src:"/use-react-workers/_astro/react.h3aPdYU7.svg",width:35.93,height:32,format:"svg"};export{z as a,K as b,J as j,V as r,Q as u};
